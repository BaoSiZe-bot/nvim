{
    "Lowbit": {
        "prefix": [
            "lb",
            "lowbit"
        ],
        "body": [
            "inline int lb(int x)",
            "{",
            "    return x & -x;",
            "}"
        ]
    },
    "Find-Union Set": {
        "prefix": [
            "fd",
            "find"
        ],
        "body": [
            "int p[100005], h[100005]; //TODO: add memset(p, 0xff, sizeof p);",
            "inline int fd(int x) // find parent",
            "{",
            "    return ~p[x] ? p[x] = fd(p[x]) : x;",
            "}",
            "inline void mg(int u, int v) // merge u, v",
            "{",
            "    u = fd(u);",
            "    v = fd(v);",
            "    if (u ^ v)",
            "    {",
            "        if (h[u] <= h[v])",
            "            p[u] = v;",
            "        else",
            "            p[v] = u;",
            "        if (h[u] == h[v])",
            "            ++h[u];",
            "    }",
            "}"
        ]
    },
    "Quick pow(mod p)": {
        "prefix": [
            "qpmod",
            "ksmmod"
        ],
        "body": [
            "static ll qp(ll a, ll b, ll p = P)",
            "{",
            "    ll res = 1;",
            "    for (; b; b >>= 1)",
            "    {",
            "        (b & 1) && ((res *= a) %= p);",
            "        (a *= a) %= p;",
            "    }",
            "    return res;",
            "}"
        ]
    },
    "Quick pow": {
        "prefix": [
            "qp",
            "ksm"
        ],
        "body": [
            "static ll qp(ll a, ll b)",
            "{",
            "    ll res = 1;",
            "    for (; b; b >>= 1)",
            "    {",
            "        (b & 1) && (res *= a);",
            "        a *= a;",
            "    }",
            "    return res;",
            "}"
        ]
    },
    "Eular": {
        "prefix": [
            "eular",
            "ola"
        ],
        "body": [
            "std::vector<int> prm;$1",
            "inline void oba(const int &lim)",
            "{",
            "    bool G[lim + 5];",
            "    for (int i = 2; i <= lim; ++i)",
            "    {",
            "        if (!G[i])",
            "            prm.push_back(i);",
            "        for (int j : prm)",
            "        {",
            "            if (i * j > lim)",
            "                break;",
            "            G[i * j] = 1;",
            "            if (i % j == 0)",
            "                break;",
            "        }",
            "    }",
            "}"
        ]
    },
    "GCD": {
        "prefix": "gcd",
        "body": [
            "inline int gcd(int x, int y)",
            "{",
            "    return y ? gcd(y, x % y) : x;",
            "}"
        ]
    },
    "oistarter": {
        "prefix": "oi",
        "body": [
            "#include <cstdio>",
            "",
            "namespace Fujiwara",
            "{",
            "using ll = long long;",
            "",
            "static void solve()",
            "{",
            "    $2",
            "}",
            "static int Azusa()",
            "{",
            "    int t = 1;",
            "    // scanf(\"%d\", &t);",
            "    while (t--)",
            "        solve();",
            "    return 0;",
            "}",
            "}  // namespace Fujiwara",
            "int main()",
            "{",
            "    freopen(\"${1:filename}.in\", \"r\", stdin);",
            "    freopen(\"$1.out\", \"w\", stdout);",
            "    return Fujiwara::Azusa();",
            "}"
        ]
    },
    "quickread": {
        "prefix": "qr",
        "body": [
            "#define Get() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)",
            "char buf[1 << 23], *p1 = buf, *p2 = buf;",
            "template <class T> inline void rd(T &x)",
            "{",
            "    x = 0;",
            "    int f = 1;",
            "    char c = Get();",
            "    for (; c < 48 || c > 57; c = Get())",
            "        c == 45 && (f = ~f + 1);",
            "    for (; c > 47 && c < 58; c = Get())",
            "        x = (x << 1) + (x << 3) + (c ^ 48);",
            "    x *= f;",
            "}",
            "template <class T, class... S> inline void rd(T &x, S &...y)",
            "{",
            "    rd(x);",
            "    rd(y...);",
            "}"
        ]
    },
    "Lucas": {
        "prefix": "Lucas",
        "body": [
            "inline int C(int m, int n, int p)",
            "{",
            "    if (n > m)",
            "        return 0;",
            "    if (m == 0 || n == 0 || n == m)",
            "        return 1;",
            "    int s = 1, t = 1;",
            "    for (int i = m - n + 1; i <= m; ++i)",
            "        s = s * i % p;",
            "    for (int i = 1; i <= n; ++i)",
            "        t = t * i % p;",
            "    return s * qp(t, p - 2, p) % p;",
            "}",
            "inline int Lucas(int m, int n, int p)  //c^n_m",
            "{",
            "    if (m == 0 || n == 0 || n == m)",
            "        return 1;",
            "    return Lucas(m / p, n / p, p) * C(m % p, n % p, p) % p;",
            "}"
        ]
    },
    "List-style forward star": {
        "prefix": "Edge",
        "body": [
            "struct Edge",
            "{",
            "    int v, w, p;",
            "} e[2005];",
            "int ed[1005], cnt;",
            "inline void add(int u, int v, int w)",
            "{",
            "    e[++cnt] = {v, w, ed[u]};",
            "    ed[u] = cnt;",
            "}"
        ]
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "int d[500005], f[22][500005];",
            "inline void dfs(int ro, int fa)",
            "{",
            "    d[ro] = d[fa] + 1;",
            "    for (int i = 1; i <= 20; ++i)",
            "        f[i][ro] = f[i - 1][f[i - 1][ro]];",
            "    for (int i = ed[ro]; i; i = e[i].pre)",
            "    {",
            "        int to = e[i].v;",
            "        if (to != fa)",
            "        {",
            "            f[0][to] = ro;",
            "            dfs(to, ro);",
            "        }",
            "    }",
            "}",
            "inline int lca(int u, int v)",
            "{",
            "    if (d[u] < d[v])",
            "        swap(u, v);",
            "    for (int i = 20; ~i; --i)",
            "    {",
            "        if (d[f[i][u]] >= d[v])",
            "            u = f[i][u];",
            "        if (u == v)",
            "            return u;",
            "    }",
            "    for (int i = 20; ~i; --i)",
            "        if (f[i][u] != f[i][v])",
            "        {",
            "            u = f[i][u];",
            "            v = f[i][v];",
            "        }",
            "    return f[0][u];",
            "}"
        ]
    },
    "tarscc": {
        "prefix": "tarscc",
        "body": [
            "int ep[500005], dfn[500005], low[500005], stk[500005], pos[500005], top, gtm, pts;",
            "inline void tarjan(int x)",
            "{",
            "    dfn[x] = low[x] = ++gtm;",
            "    stk[++top] = x;",
            "    for (int i = ed[x]; i; i = e[i].p)",
            "    {",
            "        int to = e[i].v;",
            "        if (!dfn[to])",
            "        {",
            "            tarjan(to);",
            "            low[x] = min(low[x], low[to]);",
            "        }",
            "        else if (!pos[to])",
            "            low[x] = min(low[x], dfn[to]);",
            "    }",
            "    if (dfn[x] == low[x])",
            "    {",
            "        ++pts;",
            "        int t = 0;",
            "        do",
            "            pos[t = stk[top--]] = pts;",
            "        while (t != x);",
            "    }",
            "}"
        ]
    },
    "topo": {
        "prefix": "topo",
        "body": [
            "inline void topo(int rr[], int d[], const GR &gg)",
            "{",
            "    d[pos[1]] = ptc[pos[1]];",
            "    hd = 1;",
            "    tl = 0;",
            "    for (int i = 1; i <= pts; i++)",
            "        if (!rr[i])",
            "            q[++tl] = i;",
            "    while (hd <= tl)",
            "    {",
            "        int p = q[hd++];",
            "        for (int i = gg.ed[p]; i; i = gg.e[i].p)",
            "        {",
            "            int to = gg.e[i].v;",
            "            d[to] = max(d[to], d[p] + ptc[to]);",
            "            --rr[to];",
            "            if (!rr[to])",
            "                q[++tl] = to;",
            "        }",
            "    }",
            "}"
        ]
    },
    "hungarian": {
        "prefix": "hung",
        "body": [
            "int mp[205][205], md[205], vs[205], n;",
            "inline bool Hungarian(int x)",
            "{",
            "    for (int i = 1; i <= n; ++i)",
            "        if (mp[x][i] && !vs[i])",
            "        {",
            "            vs[i] = 1;",
            "            if (!md[i] || Hungarian(md[i]))",
            "            {",
            "                md[i] = x;",
            "                return 1;",
            "            }",
            "        }",
            "    return 0;",
            "}"
        ]
    },
    "dijkstra": {
        "prefix": "dij",
        "body": [
            "int d[10005];",
            "bool f[10005];",
            "inline void dij()",
            "{",
            "    memset(d, 0x3f, sizeof(d));",
            "    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> q;",
            "    q.push({0, 1});",
            "    d[1] = 0;",
            "    while (!q.empty())",
            "    {",
            "        int nw = q.top().second;",
            "        q.pop();",
            "        if (f[nw])",
            "            continue;",
            "        f[nw] = 1;",
            "        for (int i = g.gd(nw); i; i = g.ge(i).p)",
            "        {",
            "            int to = g.ge(i).v;",
            "            if (!f[to] && d[to] > d[nw] + g.ge(i).w)",
            "            {",
            "                d[to] = d[nw] + g.ge(i).w;",
            "                q.push({d[to], to});",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "spfa": {
        "prefix": "spfa",
        "body": [
            "inline void spfa(int s)",
            "{",
            "    for (int i = 1; i <= n; ++i)",
            "        d[i] = INT_MAX;",
            "    queue<int> q;",
            "    q.push(s);",
            "    d[s] = 0;",
            "    f[s] = 1;",
            "    while(!q.empty())",
            "    {",
            "        int now = q.front();",
            "        q.pop();",
            "        f[now] = 0;",
            "        for (int i = ed[now]; i; i = e[i].p) {",
            "            int to = e[i].v;",
            "            if(d[now] + e[i].w < d[to])",
            "            {",
            "                d[to] = d[now] + e[i].w;",
            "                if(!f[to])",
            "                {",
            "                    q.push(to);",
            "                    f[to] = 1;",
            "                }",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "Segment tree": {
        "prefix": [
            "bld",
            "build"
        ],
        "body": [
            "struct Node",
            "{",
            "    int l, r;",
            "    \t${1://TODO: add data in Node}",
            "}s[3000005];",
            "inline void psd(int x)",
            "{",
            "    \t${2://TODO: add pushdown}",
            "}",
            "inline void psu(int x)",
            "{",
            "    \t${3: //TODO: add pushup}",
            "}",
            "inline void bld(int x, int l, int r)",
            "{",
            "    \t${5://TODO: add init}",
            "    if (l == r)",
            "    {",
            "        \t${6://TODO: add one-node init.}",
            "        return;",
            "    }",
            "    int mid = (l + r) >> 1;",
            "    bld(x << 1, l, mid);",
            "    bld(x << 1 | 1, mid + 1, r);",
            "    psu(x);",
            "}",
            "inline void add(int x, int l, int r, int v)",
            "{",
            "    if (l <= s[x].l && s[x].r <= r)",
            "    {",
            "        \t${7://TODO: add full add.}",
            "        return;",
            "    }",
            "    psd(x);",
            "    int mid = (s[x].l + s[x].r) >> 1;",
            "    if (l <= mid)",
            "        add(x << 1, l, r, v);",
            "    if (r > mid)",
            "        add(x << 1 | 1, l, r, v);",
            "    psu(x);",
            "}",
            "inline int qry(int x, int l, int r)",
            "{",
            "    if (l <= s[x].l && s[x].r <= r)",
            "    {",
            "        \t${8://TODO: add full return(qry).}",
            "    }",
            "    psd(x);",
            "    int mid = (s[x].l + s[x].r) >> 1;",
            "    int res = 0;",
            "    if (l <= mid)",
            "        res += qry(x << 1, l, r);",
            "    if (r > mid)",
            "        res += qry(x << 1 | 1, l, r);",
            "    return res;",
            "}",
            ""
        ]
    }
}
