{
    "Lowbit": {
        "prefix": [
            "lb",
            "lowbit"
        ],
        "body": [
            "inline int lb(int x)",
            "{",
            "    return x & -x;",
            "}"
        ]
    },
    "Find-Union Set": {
        "prefix": [
            "fd",
            "find"
        ],
        "body": [
            "int p[100005], h[100005]; //TODO: add memset(p, 0xff, sizeof p);",
            "inline int fd(int x) // find parent",
            "{",
            "    return ~p[x] ? p[x] = fd(p[x]) : x;",
            "}",
            "inline void mg(int u, int v) // merge u, v",
            "{",
            "    u = fd(u);",
            "    v = fd(v);",
            "    if (u ^ v)",
            "    {",
            "        if (h[u] <= h[v])",
            "            p[u] = v;",
            "        else",
            "            p[v] = u;",
            "        if (h[u] == h[v])",
            "            ++h[u];",
            "    }",
            "}"
        ]
    },
    "Quick pow(mod p)": {
        "prefix": [
            "qpmod",
            "ksmmod"
        ],
        "body": [
            "inline int qp(int a, int b, int p)",
            "{",
            "    int res = 1;",
            "    while(b)",
            "    {",
            "        if (b & 1)",
            "            res = res * a % p;",
            "        a = a * a % p;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ]
    },
    "Quick pow": {
        "prefix": [
            "qp",
            "ksm"
        ],
        "body": [
            "inline int qp(int a, int b)",
            "{",
            "    int res = 1;",
            "    while(b)",
            "    {",
            "        if (b & 1)",
            "            res *= a;",
            "        a *= a;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ]
    },
    "Eular": {
        "prefix": [
            "eular",
            "ola"
        ],
        "body": [
            "std::vector<int> prm;$1",
            "inline void oba(const int &lim)",
            "{",
            "    bool G[lim + 5];",
            "    for (int i = 2; i <= lim; ++i)",
            "    {",
            "        if (!G[i])",
            "            prm.push_back(i);",
            "        for (int j : prm)",
            "        {",
            "            if (i * j > lim)",
            "                break;",
            "            G[i * j] = 1;",
            "            if (i % j == 0)",
            "                break;",
            "        }",
            "    }",
            "}"
        ]
    },
    "GCD": {
        "prefix": "gcd",
        "body": [
            "inline int gcd(int x, int y)",
            "{",
            "    return y ? gcd(y, x % y) : x;",
            "}"
        ]
    },
    "quickread": {
        "prefix": "qr",
        "body": [
            "#define Get() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)",
            "char buf[1 << 23], *p1 = buf, *p2 = buf;",
            "template <class T> inline void rd(T &x)",
            "{",
            "    x = 0;",
            "    int f = 1;",
            "    char c = Get();",
            "    for (; c < 48 || c > 57; c = Get())",
            "        c == 45 && (f = ~f + 1);",
            "    for (; c > 47 && c < 58; c = Get())",
            "        x = (x << 1) + (x << 3) + (c ^ 48);",
            "    x *= f;",
            "}",
            "template <class T, class... S> inline void rd(T &x, S &...y)",
            "{",
            "    rd(x);",
            "    rd(y...);",
            "}"
        ]
    },
    "Lucas": {
        "prefix": "Lucas",
        "body": [
            "inline int C(int m, int n, int p)",
            "{",
            "    if (n > m)",
            "        return 0;",
            "    if (m == 0 || n == 0 || n == m)",
            "        return 1;",
            "    int s = 1, t = 1;",
            "    for (int i = m - n + 1; i <= m; ++i)",
            "        s = s * i % p;",
            "    for (int i = 1; i <= n; ++i)",
            "        t = t * i % p;",
            "    return s * qp(t, p - 2, p) % p;",
            "}",
            "inline int Lucas(int m, int n, int p)  //c^n_m",
            "{",
            "    if (m == 0 || n == 0 || n == m)",
            "        return 1;",
            "    return Lucas(m / p, n / p, p) * C(m % p, n % p, p) % p;",
            "}"
        ]
    },
    "List-style forward star": {
        "prefix": "Edge",
        "body": [
            "struct Edge",
            "{",
            "    int v, w, p;",
            "} e[2005];",
            "int ed[1005], cnt;",
            "inline void add(int u, int v, int w)",
            "{",
            "    e[++cnt] = {v, w, ed[u]};",
            "    ed[u] = cnt;",
            "}"
        ]
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "int d[500005], f[22][500005];",
            "inline void dfs(int ro, int fa)",
            "{",
            "    d[ro] = d[fa] + 1;",
            "    for (int i = 1; i <= 20; ++i)",
            "        f[i][ro] = f[i - 1][f[i - 1][ro]];",
            "    for (int i = ed[ro]; i; i = e[i].pre)",
            "    {",
            "        int to = e[i].v;",
            "        if (to != fa)",
            "        {",
            "            f[0][to] = ro;",
            "            dfs(to, ro);",
            "        }",
            "    }",
            "}",
            "inline int lca(int u, int v)",
            "{",
            "    if (d[u] < d[v])",
            "        swap(u, v);",
            "    for (int i = 20; ~i; --i)",
            "    {",
            "        if (d[f[i][u]] >= d[v])",
            "            u = f[i][u];",
            "        if (u == v)",
            "            return u;",
            "    }",
            "    for (int i = 20; ~i; --i)",
            "        if (f[i][u] != f[i][v])",
            "        {",
            "            u = f[i][u];",
            "            v = f[i][v];",
            "        }",
            "    return f[0][u];",
            "}"
        ]
    },
    "tarscc": {
        "prefix": "tarscc",
        "body": [
            "int ep[500005], dfn[500005], low[500005], stk[500005], pos[500005], top, gtm, pts;",
            "inline void tarjan(int x)",
            "{",
            "    dfn[x] = low[x] = ++gtm;",
            "    stk[++top] = x;",
            "    for (int i = ed[x]; i; i = e[i].p)",
            "    {",
            "        int to = e[i].v;",
            "        if (!dfn[to])",
            "        {",
            "            tarjan(to);",
            "            low[x] = min(low[x], low[to]);",
            "        }",
            "        else if (!pos[to])",
            "            low[x] = min(low[x], dfn[to]);",
            "    }",
            "    if (dfn[x] == low[x])",
            "    {",
            "        ++pts;",
            "        int t = 0;",
            "        do",
            "            pos[t = stk[top--]] = pts;",
            "        while (t != x);",
            "    }",
            "}"
        ]
    },
    "topo": {
        "prefix": "topo",
        "body": [
            "inline void topo(int rr[], int d[], const GR &gg)",
            "{",
            "    d[pos[1]] = ptc[pos[1]];",
            "    hd = 1;",
            "    tl = 0;",
            "    for (int i = 1; i <= pts; i++)",
            "        if (!rr[i])",
            "            q[++tl] = i;",
            "    while (hd <= tl)",
            "    {",
            "        int p = q[hd++];",
            "        for (int i = gg.ed[p]; i; i = gg.e[i].p)",
            "        {",
            "            int to = gg.e[i].v;",
            "            d[to] = max(d[to], d[p] + ptc[to]);",
            "            --rr[to];",
            "            if (!rr[to])",
            "                q[++tl] = to;",
            "        }",
            "    }",
            "}"
        ]
    },
    "hungarian": {
        "prefix": "hung",
        "body": [
            "int mp[205][205], md[205], vs[205], n;",
            "inline bool Hungarian(int x)",
            "{",
            "    for (int i = 1; i <= n; ++i)",
            "        if (mp[x][i] && !vs[i])",
            "        {",
            "            vs[i] = 1;",
            "            if (!md[i] || Hungarian(md[i]))",
            "            {",
            "                md[i] = x;",
            "                return 1;",
            "            }",
            "        }",
            "    return 0;",
            "}"
        ]
    },
    "dijkstra": {
        "prefix": "dij",
        "body": [
            "int d[10005];",
            "bool f[10005];",
            "inline void dij()",
            "{",
            "    memset(d, 0x3f, sizeof(d));",
            "    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> q;",
            "    q.push({0, 1});",
            "    d[1] = 0;",
            "    while (!q.empty())",
            "    {",
            "        int nw = q.top().second;",
            "        q.pop();",
            "        if (f[nw])",
            "            continue;",
            "        f[nw] = 1;",
            "        for (int i = g.gd(nw); i; i = g.ge(i).p)",
            "        {",
            "            int to = g.ge(i).v;",
            "            if (!f[to] && d[to] > d[nw] + g.ge(i).w)",
            "            {",
            "                d[to] = d[nw] + g.ge(i).w;",
            "                q.push({d[to], to});",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "spfa": {
        "prefix": "spfa",
        "body": [
            "inline void spfa(int s)",
            "{",
            "    for (int i = 1; i <= n; ++i)",
            "        d[i] = INT_MAX;",
            "    queue<int> q;",
            "    q.push(s);",
            "    d[s] = 0;",
            "    f[s] = 1;",
            "    while(!q.empty())",
            "    {",
            "        int now = q.front();",
            "        q.pop();",
            "        f[now] = 0;",
            "        for (int i = ed[now]; i; i = e[i].p) {",
            "            int to = e[i].v;",
            "            if(d[now] + e[i].w < d[to])",
            "            {",
            "                d[to] = d[now] + e[i].w;",
            "                if(!f[to])",
            "                {",
            "                    q.push(to);",
            "                    f[to] = 1;",
            "                }",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "Segment tree": {
        "prefix": [
            "bld",
            "build",
            "seg",
            "st"
        ],
        "body": [
            "using ll = long long;",
            "struct dat",
            "{",
            "    int l, r;",
            "    ${1:ll s;\n    dat(int _l = 0, int _r = 0, ll _s = 0) : l(_l), r(_r), s(_s % M)} {}",
            "};",
            "struct tag",
            "{",
            "    ${2:ll k, b;\n    tag(ll _k = 1, ll _b = 0) : k(_k), b(_b) }{}\n    bool operator==(const tag &other)\n    {\n        return ${3:k == other.k && b == other.b};\n    }",
            "};",
            "dat f(const tag &t, const dat &d)",
            "{",
            "    return $4;",
            "}",
            "tag g(const tag &x, const tag &y)",
            "{",
            "    return $5;",
            "}",
            "dat h(const dat &a, const dat &b)",
            "{",
            "    return $6;",
            "}",
            "template <const size_t N, typename dat, typename tag, typename T> struct SegmentTree",
            "{",
            "#define ci const int &",
            "#define ct const tag &",
            "#define cd const dat &",
            "    dat d[N];",
            "    tag t[N];",
            "    const tag tt;",
            "    const dat dd;",
            "    void init(T *I, ci rt, ci l, ci r)",
            "    {",
            "        d[rt] = {l, r, 0};",
            "        t[rt] = tt;",
            "        if (l == r)",
            "        {",
            "            d[rt].s = I[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) >> 1;",
            "        init(I, rt << 1, l, mid);",
            "        init(I, rt << 1 | 1, mid + 1, r);",
            "        d[rt] = h(d[rt << 1], d[rt << 1 | 1]);",
            "    }",
            "    void pushdown(ci rt)",
            "    {",
            "        if (t[rt] == tt)",
            "            return;",
            "        d[rt << 1] = f(t[rt], d[rt << 1]);",
            "        t[rt << 1] = g(t[rt], t[rt << 1]);",
            "        d[rt << 1 | 1] = f(t[rt], d[rt << 1 | 1]);",
            "        t[rt << 1 | 1] = g(t[rt], t[rt << 1 | 1]);",
            "        t[rt] = tt;",
            "    }",
            "    void upd(ci rt, ci l, ci r, ct k)",
            "    {",
            "        if (d[rt].r < l || r < d[rt].l)",
            "        {",
            "            return;",
            "        }",
            "        if (l <= d[rt].l && d[rt].r <= r)",
            "        {",
            "            t[rt] = g(k, t[rt]);",
            "            d[rt] = f(k, d[rt]);",
            "            return;",
            "        }",
            "        pushdown(rt);",
            "        upd(rt << 1, l, r, k);",
            "        upd(rt << 1 | 1, l, r, k);",
            "        d[rt] = h(d[rt << 1], d[rt << 1 | 1]);",
            "    }",
            "    dat qry(ci rt, ci x)",
            "    {",
            "        if (d[rt].r < x || x < d[rt].l)",
            "            return {0, 0, 0};",
            "        if (d[rt].l == x && x == d[rt].r)",
            "            return d[rt];",
            "        pushdown(rt);",
            "        int mid = (d[rt].l + d[rt].r) >> 1;",
            "        if (x <= mid)",
            "            return qry(rt << 1, x);",
            "        return qry(rt << 1 | 1, x);",
            "    }",
            "    dat qry(ci rt, ci l, ci r)",
            "    {",
            "        if (d[rt].r < l || r < d[rt].l)",
            "            return dd;",
            "        if (l <= d[rt].l && d[rt].r <= r)",
            "            return d[rt];",
            "        pushdown(rt);",
            "        return h(qry(rt << 1, l, r), qry(rt << 1 | 1, l, r));",
            "    }",
            "#undef ci",
            "#undef ct",
            "#undef cd",
            "};",
            "const int N = 5e5 + 5;",
            "${7:ll a[N];\nSegmentTree<N << 2, dat, tag, ll> st;}",
        ]
    }
}
